

Could you explain your project? 
Our project is an AI-powered career guidance platform that helps students bridge skill gaps and 
improve employability. It uses AI to recommend career paths based on the Japanese concept of 
Ikigai, offering personalized role roadmaps, skill-based learning modules, resume optimization, and 
interview preparation. The platform integrates real-time assessments, gamified learning, and 
project-based training. It also helps companies quickly identify suitable candidates. Built with Next.js 
and Firebase, it ensures scalability, accessibility, and a user-friendly interface for students, colleges, 
and recruiters. 
 
 
Can you explain the architecture of your project? 
The architecture of our project follows a modular, scalable design. The frontend is built using Next.js 
with React for fast, responsive UI and Tailwind CSS for styling. The backend uses Next.js API routes 
integrated with Firebase for serverless scalability and real-time database operations. We employ AI-
based systems for skill assessments and personalized recommendations. Authentication is managed 
with NextAuth (email/password), and data security includes role-based access and encryption. The 
system is designed for cross-platform compatibility, accessibility, and performance using CDN 
caching and autoscaling. 
What technologies did you utilize in your project?  
We used Next.js with React for building a responsive and dynamic frontend, styled with Tailwind 
CSS. For backend operations and real-time data handling, we integrated Firebase. Authentication is 
managed using NextAuth with email/password login. Our AI features for skill assessment and 
personalized recommendations are powered by data-driven algorithms. We also used Yup and 
Formik for input validation, and implemented accessibility features like scalable fonts and color 
contrast. The tech stack ensures a seamless, secure, and scalable experience across all devices. 
 
Could you outline the modules present in your project? 
Our project includes several key modules: 
1. User Module – Handles student registration, branch selection, and personalized 
career path recommendations. 
2. AI Assessment Module – Evaluates skills, interests, and provides role-specific 
guidance using the Ikigai framework. 
3. Learning Module – Offers interactive, gamified courses with ancient Indian 
techniques like Śravaṇam and Mananam. 
4. Resume Analyzer – Optimizes resumes based on job descriptions. 
5. Company Module – Enables recruiters to post roles and access pre-assessed 
candidate lists. 
6. Admin Module – Manages users, content, and analytics. 
 
 

What types of users were involved in your project? 
Our project supports three main user types: 
1. Students/Job Seekers – They access personalized career paths, take AI-driven 
assessments, learn through interactive modules, and optimize their resumes. 
2. Companies/Recruiters – They can post job roles, scan optimized resumes, and 
quickly connect with qualified candidates. 
3. Colleges/Educators – Institutions purchase bulk logins, assign them to students, and 
track their progress to improve placement outcomes. 
Each user type has a tailored interface and functionalities to suit their specific goals 
and needs. 
 
How many tables are present in the project? 
Since we used Firebase as our backend, we structured data in collections rather than 
traditional tables. Key collections include: 
1. Users – Stores student profiles and preferences. 
2. Assessments – Contains AI-based skill test results. 
3. Courses – Includes learning modules and progress tracking. 
4. Resumes – Holds uploaded resumes and optimization data. 
5. Companies – Stores recruiter profiles and job listings. 
6. Applications – Tracks student applications to roles. 
These collections function like relational tables but are optimized for scalability and 
real-time performance. 
 
Which tables hold significant importance in the project? 
The most significant collections (tables) in our project are: 
1. Users – Central to the system, it stores student data, preferences, and progress. 
2. Assessments – Crucial for AI-driven skill evaluation and personalized role 
recommendations. 
3. Courses – Tracks learning paths, completion status, and engagement. 
4. Companies – Manages recruiter details and job postings. 
5. Resumes – Supports resume scanning and optimization based on job roles. 
These collections drive core features like career mapping, job matching, and skill 
development. 
 
 
 

You have created a backend or web-based application? 
We developed a web-based application with both frontend and backend components. The frontend 
is built using Next.js and React, offering a responsive and user-friendly interface. The backend is 
implemented using Next.js API routes and Firebase, enabling real-time database interactions, 
authentication, and AI-based assessments. While it's web-based, the architecture ensures backend 
functionality for handling user data, processing AI logic, and supporting recruiter interactions 
securely and efficiently. 
 How many REST APIs did you develop? 
We developed around 10–12 REST APIs using Next.js API routes to manage various backend 
operations. These APIs handle tasks such as user registration and login, skill assessment 
submission, career recommendations, course progress tracking, resume upload and analysis, and 
job role management by companies. Each API is designed to be modular, secure, and optimized for 
performance, supporting seamless communication between the frontend and backend while 
ensuring scalability and real-time data handling. 
 How many REST APIs / Test Cases did you develop? 
We developed approximately 10–12 REST APIs to handle key functionalities such as user 
authentication, skill assessments, course progress, resume analysis, and job role management. 
Alongside this, we created around 15–20 test cases to ensure API reliability and application stability. 
These include unit tests and integration tests using tools like React Testing Library, ensuring each 
module behaves as expected, maintains data integrity, and performs well under various user 
scenarios. 
 
Could you provide an explanation of any specific API or Test Cases you 
developed? 
One specific API we developed is the Job Scraping API, which fetches real-time job listings 
from various external platforms based on the user's skills and interests. It uses AI to filter and 
recommend jobs that align with the user’s profile. We created test cases to validate data 
accuracy, response time, error handling for unavailable sources, and relevance of scraped 
jobs. This API plays a vital role in enhancing job visibility for students by connecting them 
with live market opportunities. 
 
What were your main responsibilities within the project?  
My main responsibilities included working as a Full Stack Developer, where I handled both frontend 
and backend tasks. I designed and developed user interfaces using React and Next.js, styled them 
with Tailwind CSS, and integrated real-time functionalities using Firebase. I also built key REST APIs 
like Job Scraping and Resume Analysis, implemented authentication, and ensured data flow 
between modules. Additionally, I contributed to AI integration, testing, and maintaining code 
quality through modular design and code reviews. 
 

or 
As the Frontend Developer, my main responsibility was to design and build a responsive, user-
friendly interface using React and Next.js, styled with Tailwind CSS. I developed components for 
user registration, skill assessments, career roadmap visualization, and resume upload. I focused on 
ensuring cross-device compatibility, accessibility, and smooth user interactions. I also integrated 
frontend logic with backend APIs like Job Scraping and AI-based recommendations, handled form 
validations using Yup and Formik, and maintained code quality through modular and reusable 
components. 
 
What were your main responsibilities within the project? 
As the Frontend Developer, my main responsibilities were to design and implement a responsive 
and accessible user interface using React, Next.js, and Tailwind CSS. I created reusable UI 
components for key features like user registration, skill assessments, career recommendations, and 
resume uploads. I integrated frontend components with backend APIs such as the Job Scraping API, 
ensured proper form validation using Yup and Formik, and optimized the UI for all device types. I 
also focused on maintaining clean, modular code and improving user experience. 
 
Could you provide an explanation of any specific API or test case you 
developed? 
As the Frontend Developer, my main responsibilities were to design and implement a 
responsive and accessible user interface using React, Next.js, and Tailwind CSS. I created 
reusable UI components for key features like user registration, skill assessments, career 
recommendations, and resume uploads. I integrated frontend components with backend APIs 
such as the Job Scraping API, ensured proper form validation using Yup and Formik, and 
optimized the UI for all device types. I also focused on maintaining clean, modular code and 
improving user experience. 
 
Can you discuss your user roles within the project? 
Yes, we defined three main user roles in the project: 
1. Student/Job Seeker – Can register, take skill assessments, get career 
recommendations, learn through courses, and upload resumes. 
2. Company/Recruiter – Can log in, post job roles, view AI-optimized candidate 
profiles, and shortlist applicants. 
3. College/Admin – Can purchase bulk logins, assign them to students, and track their 
progress. 
Each role has specific permissions and dashboards, implemented using role-based 
access control (RBAC) to ensure secure and personalized user experiences. 
 

What challenges did you encounter during the project?  
One major challenge was ensuring smooth integration of AI features like job recommendations and 
skill assessments with a dynamic frontend. Managing real-time data syncing using Firebase while 
maintaining performance was also tricky. Designing a UI that’s both visually appealing and fully 
accessible across all devices required careful planning. Additionally, handling form validation, 
multilingual support, and gamified learning elements added complexity. We overcame these 
challenges through collaborative problem-solving, testing, and iterative UI improvements. 
 
What utilities did you develop as part of your project? 
As part of the project, we developed several utilities to enhance functionality and user 
experience. These include: 
• An AI-based Job Scraping Utility to fetch relevant job listings in real-time. 
• A Resume Scanner Utility that analyzes resumes and suggests improvements based 
on job roles. 
• A Career Recommendation Engine using the Ikigai framework. 
• Form validation utilities using Yup and Formik for secure and smooth user input. 
• A Gamification Tracker to monitor progress and engagement. 
These utilities made the platform smarter, more interactive, and user-friendly. 
 
✅ 1. Responsive Design Across Devices 
Difficulty: 
• Designing a consistent and visually appealing interface that works seamlessly on 
mobiles, tablets, and desktops. 
• Handling layout shifts and ensuring proper content scaling. 
Solution: 
• Used Tailwind CSS for utility-first responsive design. 
• Applied Tailwind's responsive classes (sm:, md:, lg:) to adapt components to various 
screen sizes. 
• Regularly tested the UI on different screen resolutions and devices using Chrome 
DevTools. 
 
✅ 2. Form Validation and Handling User Input 
Difficulty: 
• Complex, multi-step forms needed real-time validation and dynamic error messages. 

• Ensuring smooth user input experience and handling edge cases like missing or 
invalid data. 
Solution: 
• Implemented Formik for form state management and Yup for schema-based 
validation. 
• Used conditional rendering to provide real-time feedback and custom error messages. 
• Enabled smooth transitions between form steps after successful validation. 
 
✅ 3. Integration with Backend APIs (e.g., Job Scraping, Resume Analysis) 
Difficulty: 
• Handling asynchronous data from APIs and reflecting it in the UI without delays or 
bugs. 
• Managing loading states, error handling, and data updates efficiently. 
Solution: 
• Used Axios and Fetch API for making HTTP requests. 
• Handled loading, success, and error states using React’s useState and useEffect 
hooks. 
• Created reusable utility functions for consistent API interaction patterns. 
 
✅ 4. Dynamic UI Updates Based on AI Recommendations 
Difficulty: 
• Displaying personalized career paths, job recommendations, and assessment results 
dynamically based on user data. 
• Ensuring state consistency across multiple components. 
Solution: 
• Used React Context API to manage global state where needed. 
• Built reusable, parameterized components for displaying recommendation cards, 
roadmaps, and progress. 
• Fetched data using useEffect and updated state cleanly with useState. 
 
✅ 5. Ensuring Accessibility 
Difficulty: 

• Making sure that the app was usable for all users, including those with visual 
impairments or other disabilities. 
Solution: 
• Followed WCAG guidelines for contrast ratios and text sizes. 
• Used semantic HTML, aria-labels, keyboard navigation support, and proper focus 
management. 
• Ensured that color schemes, fonts, and interactive elements were readable and usable. 
 
✅ 6. Component Reusability and Clean Code Maintenance 
Difficulty: 
• Avoiding duplicate code and ensuring scalability as the UI grew more complex. 
Solution: 
• Designed reusable components (e.g., buttons, cards, form inputs) and stored them in a 
centralized components/ folder. 
• Followed a modular folder structure (pages/, components/, lib/, styles/) to keep 
code organized. 
• Used ESLint + Prettier for consistent formatting and clean code practices. 
 
✅ 7. Real-Time Data Handling with Firebase 
Difficulty: 
• Reflecting real-time updates like course progress, skill test results, and job 
applications in the UI. 
Solution: 
• Integrated Firebase Firestore with React using listeners (onSnapshot) to fetch live 
data. 
• Ensured data was correctly mapped to UI components using efficient rendering 
techniques like .map() with proper keys. 
• Handled loading states and fallback UI when data was still being fetched. 
 
✅ 8. Performance Optimization 
Difficulty: 

• Large components or unnecessary renders were affecting UI speed and 
responsiveness. 
Solution: 
• Used React.memo, lazy loading (React.lazy, Suspense), and conditional rendering 
to optimize performance. 
• Minimized re-renders by managing state at the lowest possible level. 
 
✅ 9. Handling Multilingual Support 
Difficulty: 
• Ensuring content was accessible and meaningful in multiple languages for a wider 
audience. 
Solution: 
• Integrated a basic translation utility to switch between languages. 
• Used i18n (internationalization) strategies and language JSON files to manage 
translations easily. 
 
✅ 10. User Engagement with Gamified UI 
Difficulty: 
• Creating a gamified learning interface that encouraged users to complete tasks 
without feeling overwhelmed. 
Solution: 
• Designed progress bars, badges, daily streak counters, and leaderboards to track 
engagement. 
• Used React state management to show achievements and guide users through daily 
goals. 
 
 
 
 
 2. How did you manage form validation? 
Answer: 
I used Formik for managing form state and submission, and Yup for schema-based 

validation. This allowed real-time error feedback, conditional validations, and clean handling 
of complex multi-step forms such as registration, assessments, and resume uploads. 
 
 3. How did you ensure the UI was responsive and accessible? 
Answer: 
I used Tailwind CSS with mobile-first responsive classes. For accessibility, I followed 
WCAG guidelines, used semantic HTML, proper color contrast, and added aria-labels 
for screen readers. I also tested the UI across multiple devices and screen sizes. 
 
 4. What were the major frontend challenges you faced? 
Answer: 
Challenges included: 
• Making the UI fully responsive 
• Handling real-time Firebase data efficiently 
• Implementing AI-based dynamic content rendering 
• Managing multi-language support 
• Keeping performance high with large data sets 
I solved these with modular component design, React hooks, and optimized data 
fetching. 
 
 5. Can you explain your role-based access handling on the frontend? 
Answer: 
I used Firebase Auth to manage user authentication. Based on the user role (student, 
company, or admin), the UI dynamically rendered relevant dashboards using conditional 
rendering and protected routes. This ensured each role only accessed the appropriate 
features. 
 
 6. How did you connect frontend to the backend/API? 
Answer: 
I used Axios and the Fetch API to call REST APIs developed in Next.js API routes. I 
managed the responses using useEffect and useState for handling data loading, success, 
and error states in a clean and user-friendly way. 
 

 7. How did you implement the Job Scraping feature on the frontend? 
Answer: 
I built a UI component where users input skills or job roles. On submission, the frontend hits 
our Job Scraping API, fetches relevant job listings, and displays them in a card layout with 
filters. Loading and error states were clearly handled using React state. 
 
 8. How did you manage component reusability? 
Answer: 
I created modular components (e.g., buttons, cards, forms, input fields) and stored them in a 
centralized components/ folder. This allowed easy reuse across multiple pages and ensured 
consistency. I followed a naming convention and folder structure to maintain clean code. 
 
 9. Did you write any test cases for the frontend? 
Answer: 
Yes, I used React Testing Library for unit and integration testing. I tested form submission, 
validation behavior, API response rendering, and role-based UI rendering to ensure the 
components behaved as expected in various scenarios. 
 
 10. How did you optimize frontend performance? 
Answer: 
I used techniques like: 
• React.memo for preventing unnecessary re-renders 
• Lazy loading components with React.lazy() 
• Optimized image usage 
• Reduced bundle size using code splitting 
This helped ensure the app loads quickly and remains responsive even with real-time 
data. 
 
 